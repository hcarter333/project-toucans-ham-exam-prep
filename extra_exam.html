<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Extra Class Practice Exam (Stacked Bars with Toggle Groups)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <!-- Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.4/dist/chart.umd.min.js"></script>
  <style>
    :root { font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; }
    body { margin: 2rem; }
    h1 { margin-top: 0; }
    .toolbar { display:flex; gap:.5rem; align-items:center; margin-bottom:1rem; flex-wrap:wrap;}
    .btn { cursor:pointer; padding:.5rem .75rem; border:1px solid #ccc; border-radius:.5rem; background:#f7f7f7; }
    .btn:disabled { opacity:.6; cursor:not-allowed; }
    .muted { color:#777; font-size:.9rem; }
    .card { border:1px solid #e5e5e5; border-radius:12px; padding:1rem; margin:1rem 0; box-shadow:0 1px 3px rgba(0,0,0,.05); }
    .qid { font-weight:600; color:#555; margin-bottom:.25rem; }
    .qtext { margin:.25rem 0 .75rem; line-height:1.5; }
    .controls { display:flex; gap:.5rem; align-items:center; flex-wrap:wrap; }
    select { padding:.4rem .5rem; max-width: 100%; white-space: normal;  }
    .result { margin-top:.5rem; font-weight:600; }
    .correct { color:#0a7b34; }
    .incorrect { color:#b00020; }
    #summary { margin-top:2rem; padding:1rem; border:2px dashed #ddd; border-radius:12px; background:#fafafa; }

    #charts { margin-top:2rem; }
    .section-title { margin-top:2rem; margin-bottom:.5rem; }
    .charts-note { color:#555; font-size:.9rem; margin-bottom:.5rem; }

    /* 10-across grids for compact chart tiles */
    .grid10 { display:grid; grid-template-columns: repeat(10, minmax(80px, 1fr)); gap: 8px; align-items:start; }

    .chart-card { border:1px solid #eee; border-radius:12px; padding:8px; }
    .chart-title-row { display:flex; align-items:center; justify-content:space-between; gap:6px; margin-bottom:6px; }
    .chart-title { font-weight:600; font-size:.9rem; margin:0; }
    .caret-btn { cursor:pointer; border:1px solid #ddd; background:#fafafa; border-radius:6px; padding:2px 6px; line-height:1; }
    .caret-btn[hidden] { display:none; }

    /* Group details row (appears one row below subelement grid) */
    #groupDetails { margin-top: 10px; }
    .sub-section { margin-top: 12px; }
  </style>
</head>
<body>
  <h1>Extra Class Practice Exam</h1>

  <div class="toolbar">
    <button id="newExamBtn" class="btn" disabled>New exam</button>
  </div>

  <div id="charts">
    <h2 class="section-title">Performance Dashboard</h2>
    <div class="charts-note">Cumulative charts and score history (persisted via <code>#c=...</code> in the URL).</div>

    <div class="chart-card" style="margin-bottom:12px;">
      <canvas id="scoresOverTime" height="140"></canvas>
    </div>

    <h3 class="section-title">Correct vs Wrong by Subelement</h3>
    <div id="subelementGrid" class="grid10"></div>
    <!-- Group charts appear one row below subelements -->
    <div id="groupDetails"></div>
  </div>

  <div id="exam"></div>

  <div id="summary" hidden>
    <h2>Your Score</h2>
    <p id="scoreLine"></p>
    <details>
      <summary>What was tracked? (this test)</summary>
      <pre id="tracking" style="white-space:pre-wrap;"></pre>
    </details>
  </div>

  <script>
    
    // ---------- Helpers ----------
    function groupKey(q) { return `E${q.subelement}${q.group_index}`; }
    function subKey(q)   { return `E${q.subelement}`; }
    function pickRandom(arr) { return arr[Math.floor(Math.random() * arr.length)]; }
    function letterToField(letter) {
      const map = { A: "answer_a", B: "answer_b", C: "answer_c", D: "answer_d" };
      return map[letter] || null;
    }
    function sanitize(text) { return (text ?? "").toString().replace(/\s+/g, " ").trim(); }
    const nowIso = () => new Date().toISOString();

    // Base64URL encode/decode JSON for hash
    function encodeState(obj) {
      const json = JSON.stringify(obj);
      const b64 = btoa(unescape(encodeURIComponent(json)));
      return b64.replace(/\+/g,'-').replace(/\//g,'_').replace(/=+$/,'');
    }
    function decodeState(s) {
      try {
        const b64 = s.replace(/-/g,'+').replace(/_/g,'/');
        const pad = b64.length % 4 ? '='.repeat(4 - (b64.length % 4)) : '';
        const json = decodeURIComponent(escape(atob(b64 + pad)));
        return JSON.parse(json);
      } catch { return null; }
    }

    // ---------- Charts ----------
    let scoresChart = null;
    const subelementCharts = []; // small stacked bars for subelements
    const groupCharts = [];      // small stacked bars for groups (current expanded)
    let currentExpandedSub = null; // e.g. 'E1'

    function destroyCharts(arr) {
      while (arr.length) {
        const ch = arr.pop();
        try { ch.destroy(); } catch {}
      }
    }

    function clearCharts() {
      if (scoresChart) { try { scoresChart.destroy(); } catch {} scoresChart = null; }
      destroyCharts(subelementCharts);
      destroyCharts(groupCharts);
      document.getElementById('subelementGrid').innerHTML = '';
      document.getElementById('groupDetails').innerHTML = '';
      currentExpandedSub = null;
    }

    function renderScoresOverTime(history) {
      const ctx = document.getElementById('scoresOverTime').getContext('2d');
      const labels = history.map(h => new Date(h.ts).toLocaleString());
      const data   = history.map(h => h.scorePct);
      scoresChart = new Chart(ctx, {
        type: 'bar',
        data: { labels, datasets: [{ label: 'Test Score (%)', data }] },
        options: { responsive: true, scales: { y: { beginAtZero: true, max: 100 } } }
      });
    }

    // Small stacked bar: green (correct) bottom, red (wrong) top
    function createStackedBar(canvas, correct, wrong) {
      return new Chart(canvas.getContext('2d'), {
        type: 'bar',
        data: {
          labels: [''],
          datasets: [
            { label: 'Correct', data: [correct], stack: 's', backgroundColor: '#0a7b34' },
            { label: 'Wrong',   data: [wrong],   stack: 's', backgroundColor: '#b00020' }
          ]
        },
        options: {
          responsive: true,
          plugins: {
            legend: { display: false },
            tooltip: {
          //enabled: true,
          backgroundColor: '#333',          // dark background
          titleColor: '#fff',
          bodyColor: '#fff',                // white text
          titleFont: {
            family: 'Verdana, sans-serif',  // font family for title
            size: 4,
            weight: 'normal'
          },
          bodyFont: {
            family: 'Verdana, sans-serif',  // font family for body
            size: 12
          },
              callbacks: {
                footer: () => `Total: ${correct + wrong}`
              }
            }
          },
          scales: {
            x: { stacked: true, ticks: { display: false }, grid: { display: false }, border: { display: false } },
            y: { stacked: true, beginAtZero: true, ticks: { display: false }, grid: { display: false }, border: { display: false } }
          }
        }
      });
    }

    function renderSubelementStacks(subStats, groupsStats) {
      const grid = document.getElementById('subelementGrid');
      grid.innerHTML = '';
      destroyCharts(subelementCharts);

      const subs = Object.keys(subStats).sort((a,b)=>parseInt(a.slice(1))-parseInt(b.slice(1)));
      subs.forEach(sub => {
        const {correct=0, wrong=0} = subStats[sub] || {};
        const card = document.createElement('div');
        card.className = 'chart-card';

        const row = document.createElement('div');
        row.className = 'chart-title-row';

        const title = document.createElement('div');
        title.className = 'chart-title';
        title.textContent = `${sub}`;

        const caret = document.createElement('button');
        caret.className = 'caret-btn';
        caret.innerHTML = (currentExpandedSub === sub) ? '&#9650;' : '&#9660;';

        // Only show caret if we have any groups recorded for this subelement
        const hasGroups = !!(groupsStats && groupsStats[sub] && Object.keys(groupsStats[sub]).length);
        if (!hasGroups) caret.hidden = true;

        caret.addEventListener('click', () => {
          if (currentExpandedSub === sub) {
            // collapse
            currentExpandedSub = null;
            caret.innerHTML = '&#9660;';  // ▼
            document.getElementById('groupDetails').innerHTML = '';
            destroyCharts(groupCharts);
            // reset other carets to ▼
            Array.from(document.querySelectorAll('.caret-btn')).forEach(btn => { if (!btn.hidden) btn.innerHTML = '&#9660;'; });
          } else {
            // expand this sub, collapse any previous
            currentExpandedSub = sub;
            Array.from(document.querySelectorAll('.caret-btn')).forEach(btn => { if (!btn.hidden) btn.innerHTML = '&#9650;'; });
            caret.innerHTML = '&#9650;';  // ▲
            renderGroupStacksForSub(sub);
          }
        });

        row.appendChild(title);
        row.appendChild(caret);
        card.appendChild(row);

        const canvas = document.createElement('canvas');
        canvas.height = 110;
        card.appendChild(canvas);
        grid.appendChild(card);

        const chart = createStackedBar(canvas, correct, wrong);
        subelementCharts.push(chart);
      });
    }

    function renderGroupStacksForSub(sub) {
      // Clear previous group charts
      const holder = document.getElementById('groupDetails');
      holder.innerHTML = '';
      destroyCharts(groupCharts);

      // Build section for this sub
      const section = document.createElement('section');
      section.className = 'sub-section';

      const h = document.createElement('h4');
      h.textContent = `Groups in ${sub}`;
      section.appendChild(h);

      const grid = document.createElement('div');
      grid.className = 'grid10';

      const groupsObj = state.stats.groups[sub] || {};
      const groups = Object.keys(groupsObj).sort();

      groups.forEach(g => {
        const {correct=0, wrong=0} = groupsObj[g] || {};
        const card = document.createElement('div');
        card.className = 'chart-card';

        const row = document.createElement('div');
        row.className = 'chart-title-row';

        const title = document.createElement('div');
        title.className = 'chart-title';
        title.textContent = `${sub}${g}`;

        row.appendChild(title);
        // no caret in group tiles
        card.appendChild(row);

        const canvas = document.createElement('canvas');
        canvas.height = 110;
        card.appendChild(canvas);
        grid.appendChild(card);

        const chart = createStackedBar(canvas, correct, wrong);
        groupCharts.push(chart);
      });

      section.appendChild(grid);
      holder.appendChild(section);
    }

    function renderAllCharts(stats) {
      clearCharts();
      renderScoresOverTime(stats.history || []);
      renderSubelementStacks(stats.subelements || {}, stats.groups || {});
      // group charts are lazy; nothing rendered here until a caret is clicked
    }

    // ---------- App state ----------
    const state = {
      all: [],
      selected: [],
      answered: new Map(),
      presentedIds: [],
      correctIds: new Set(),
      wrongIds: new Set(),
      done: false,
      stats: {
        history: [],       // [{ts, scorePct}]
        subelements: {},   // { E1:{correct,wrong}, ... }
        groups: {}         // { E1:{ A:{correct,wrong}, ... }, ... }
      }
    };

    // ---------- Loaders ----------
    async function loadFromFetch() {
      const res = await fetch('extra_pool.json', { cache: 'no-store' });
      if (!res.ok) throw new Error(`Failed to fetch extra_pool.json (${res.status})`);
      return res.json();
    }
    function loadFromFile(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onerror = () => reject(reader.error);
        reader.onload = () => {
          try { resolve(JSON.parse(reader.result)); } catch (e) { reject(e); }
        };
        reader.readAsText(file);
      });
    }

    // ---------- Exam logic ----------
    function buildExam(questions) {
      const buckets = new Map();
      for (const q of questions) {
        const key = groupKey(q);
        if (!buckets.has(key)) buckets.set(key, []);
        buckets.get(key).push(q);
      }
      const chosen = [];
      for (const [, arr] of buckets.entries()) chosen.push(pickRandom(arr));
      chosen.sort((a,b) => {
        const an = parseInt(a.subelement,10), bn = parseInt(b.subelement,10);
        if (an !== bn) return an - bn;
        return a.group_index.localeCompare(b.group_index);
      });
      return chosen;
    }

    function renderExam() {
      const container = document.getElementById('exam');
      container.innerHTML = "";
      state.answered.clear();
      state.correctIds.clear();
      state.wrongIds.clear();
      state.done = false;
      state.presentedIds = state.selected.map(q => q.id);

      for (const q of state.selected) {
        const card = document.createElement('div');
        card.className = 'card';

        const header = document.createElement('div');
        header.className = 'qid';
        header.textContent = `E${q.subelement}${q.group_index}${q.group_number} (id ${q.id})`;
        card.appendChild(header);

        const qtext = document.createElement('div');
        qtext.className = 'qtext';
        qtext.textContent = sanitize(q.question);
        card.appendChild(qtext);

        const controls = document.createElement('div');
        controls.className = 'controls';

        const select = document.createElement('select');
        select.innerHTML = `<option value="">-- choose an answer --</option>`;
        ['A','B','C','D'].forEach(letter => {
          const field = letterToField(letter);
          const txt = sanitize(q[field]);
          if (!txt) return;
          const opt = document.createElement('option');
          opt.value = letter;
          opt.textContent = `${letter}. ${txt}`;
          select.appendChild(opt);
        });

        const btn = document.createElement('button');
        btn.className = 'btn';
        btn.textContent = 'Submit answer';

        const result = document.createElement('div');
        result.className = 'result';

        btn.addEventListener('click', () => {
          if (!select.value) { alert('Please choose an answer first.'); return; }
          if (select.disabled) return;

          const chosenLetter = select.value;
          const correctLetter = (q.answer || '').trim().toUpperCase();
          const isCorrect = chosenLetter === correctLetter;

          state.answered.set(q.id, { selected: chosenLetter, correct: isCorrect });

          const correctField = letterToField(correctLetter);
          const correctText = sanitize(correctField ? q[correctField] : "");
          if (isCorrect) {
            result.textContent = 'Correct answer';
            result.classList.remove('incorrect');
            result.classList.add('correct');
            state.correctIds.add(q.id);
          } else {
            result.textContent = `Incorrect. The correct answer was: ${correctText || correctLetter}`;
            result.classList.remove('correct');
            result.classList.add('incorrect');
            state.wrongIds.add(q.id);
          }

          select.disabled = true;
          btn.disabled = true;

          if (state.answered.size === state.selected.length && !state.done) {
            state.done = true;
            finalizeTestAndRender();
          }
        });

        controls.appendChild(select);
        controls.appendChild(btn);
        card.appendChild(controls);
        card.appendChild(result);
        container.appendChild(card);
      }
    }

    function finalizeTestAndRender() {
      const total = state.selected.length;
      const correct = state.correctIds.size;
      const pct = Math.round((correct / total) * 100);
      const pass = pct >= 80;

      const summary = document.getElementById('summary');
      const scoreLine = document.getElementById('scoreLine');
      scoreLine.textContent = pass
        ? `You passed with ${pct}% (${correct}/${total} correct).`
        : `You failed with ${pct}% (${correct}/${total} correct).`;

      const tracking = {
        presented_question_ids: state.presentedIds,
        correct_question_ids: Array.from(state.correctIds),
        wrong_question_ids: Array.from(state.wrongIds)
      };
      document.getElementById('tracking').textContent = JSON.stringify(tracking, null, 2);
      summary.hidden = false;

      accumulateStatsFromCurrentTest();
      state.stats.history.push({ ts: nowIso(), scorePct: pct });

      renderAllCharts(state.stats);
      document.getElementById('newExamBtn').disabled = false;
      window.scrollTo({ top: document.getElementById('charts').offsetTop, behavior: 'smooth' });
    }

    function accumulateStatsFromCurrentTest() {
      for (const q of state.selected) {
        const keySub = `E${q.subelement}`;
        const keyGrp = q.group_index;
        const wasCorrect = state.correctIds.has(q.id);

        if (!state.stats.subelements[keySub]) state.stats.subelements[keySub] = { correct:0, wrong:0 };
        state.stats.subelements[keySub][wasCorrect ? 'correct':'wrong']++;

        if (!state.stats.groups[keySub]) state.stats.groups[keySub] = {};
        if (!state.stats.groups[keySub][keyGrp]) state.stats.groups[keySub][keyGrp] = { correct:0, wrong:0 };
        state.stats.groups[keySub][keyGrp][wasCorrect ? 'correct':'wrong']++;
      }
    }

    function startNewExam(questions) {
      state.selected = buildExam(questions);
      document.getElementById('summary').hidden = true;
      renderExam();
    }

    // ---------- Hash state (persist across runs) ----------
    function updateHashWithStats() {
      const encoded = encodeState(state.stats);
      const url = location.origin + location.pathname + '#c=' + encoded;
      location.assign(url);
    }

    function restoreStatsFromHash() {
      const m = location.hash.match(/^#c=([^&]+)/);
      if (!m) return false;
      const data = decodeState(m[1]);
      if (!data) return false;
      state.stats.history     = Array.isArray(data.history) ? data.history : [];
      state.stats.subelements = typeof data.subelements === 'object' && data.subelements ? data.subelements : {};
      state.stats.groups      = typeof data.groups === 'object' && data.groups ? data.groups : {};
      renderAllCharts(state.stats);
      return true;
    }

    // ---------- UI wiring ----------

    document.getElementById('newExamBtn').addEventListener('click', () => {
      updateHashWithStats();          // persist cumulative stats in URL
      if (state.all.length) startNewExam(state.all); // build next exam without reload
    });

    // On first load: restore from #c= if present
    restoreStatsFromHash();


const QUESTION_POOL_URL =
  "https://raw.githubusercontent.com/hcarter333/project-toucans-ham-exam-prep/refs/heads/main/extra_pool.json";

async function init() {
  try {
    const res = await fetch(QUESTION_POOL_URL);
    if (!res.ok) throw new Error(`HTTP ${res.status}`);
    state.all = await res.json();
    startNewExam(state.all);
    document.getElementById('newExamBtn').disabled = false;
  } catch (e) {
    console.error("Could not auto-load questions:", e);
    alert("Could not load question pool from GitHub.");
  }
}
window.addEventListener('DOMContentLoaded', init);
</script>
</body>
</html>
