<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Extra Class Practice Exam (Stacked Bars)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <!-- Chart.js CDN -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.4/dist/chart.umd.min.js"></script>
  <style>
    :root { font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; }
    body { margin: 2rem; }
    h1 { margin-top: 0; }
    .toolbar { display:flex; gap:.5rem; align-items:center; margin-bottom:1rem; flex-wrap:wrap;}
    .btn { cursor:pointer; padding:.5rem .75rem; border:1px solid #ccc; border-radius:.5rem; background:#f7f7f7; }
    .btn:disabled { opacity:.6; cursor:not-allowed; }
    .muted { color:#777; font-size:.9rem; }
    .card { border:1px solid #e5e5e5; border-radius:12px; padding:1rem; margin:1rem 0; box-shadow:0 1px 3px rgba(0,0,0,.05); }
    .qid { font-weight:600; color:#555; margin-bottom:.25rem; }
    .qtext { margin:.25rem 0 .75rem; line-height:1.5; }
    .controls { display:flex; gap:.5rem; align-items:center; flex-wrap:wrap; }
    select { padding:.4rem .5rem; }
    .result { margin-top:.5rem; font-weight:600; }
    .correct { color:#0a7b34; }
    .incorrect { color:#b00020; }
    #summary { margin-top:2rem; padding:1rem; border:2px dashed #ddd; border-radius:12px; background:#fafafa; }
    #charts { margin-top:2rem; }
    .section-title { margin-top:2rem; margin-bottom:.5rem; }
    .charts-note { color:#555; font-size:.9rem; margin-bottom:.5rem; }

    /* Chart cards + 10-across layout */
    .grid10 { display:grid; grid-template-columns: repeat(10, minmax(80px, 1fr)); gap: 8px; }
    .chart-card { border:1px solid #eee; border-radius:12px; padding:8px; }
    .chart-title { font-weight:600; font-size:.9rem; margin:0 0 6px 0; }
    .sub-section { margin-top: 12px; }
  </style>
</head>
<body>
  <h1>Extra Class Practice Exam</h1>

  <div class="toolbar">
    <button id="loadBtn" class="btn">Load questions (extra_pool.json)</button>
    <span class="muted">or choose a JSON file:</span>
    <input id="fileInput" type="file" accept="application/json" />
    <button id="newExamBtn" class="btn" disabled>New exam</button>
  </div>

  <div id="charts">
    <h2 class="section-title">Performance Dashboard</h2>
    <div class="charts-note">Cumulative charts and score history (persisted via <code>#c=...</code> in the URL).</div>
    <div class="chart-card" style="margin-bottom:12px;">
      <canvas id="scoresOverTime" height="140"></canvas>
    </div>

    <h3 class="section-title">Correct vs Wrong by Subelement</h3>
    <div id="subelementGrid" class="grid10"></div>

    <h3 class="section-title">Correct vs Wrong by Group (within each Subelement)</h3>
    <div id="groupGrid"></div>
  </div>

  <div id="exam"></div>

  <div id="summary" hidden>
    <h2>Your Score</h2>
    <p id="scoreLine"></p>
    <details>
      <summary>What was tracked? (this test)</summary>
      <pre id="tracking" style="white-space:pre-wrap;"></pre>
    </details>
  </div>

  <script>
    // ---------- Helpers ----------
    function groupKey(q) { return `E${q.subelement}${q.group_index}`; }
    function subKey(q)   { return `E${q.subelement}`; }
    function pickRandom(arr) { return arr[Math.floor(Math.random() * arr.length)]; }
    function letterToField(letter) {
      const map = { A: "answer_a", B: "answer_b", C: "answer_c", D: "answer_d" };
      return map[letter] || null;
    }
    function sanitize(text) { return (text ?? "").toString().replace(/\s+/g, " ").trim(); }
    const nowIso = () => new Date().toISOString();

    // Base64URL encode/decode JSON for hash
    function encodeState(obj) {
      const json = JSON.stringify(obj);
      const b64 = btoa(unescape(encodeURIComponent(json)));
      return b64.replace(/\+/g,'-').replace(/\//g,'_').replace(/=+$/,'');
    }
    function decodeState(s) {
      try {
        const b64 = s.replace(/-/g,'+').replace(/_/g,'/');
        const pad = b64.length % 4 ? '='.repeat(4 - (b64.length % 4)) : '';
        const json = decodeURIComponent(escape(atob(b64 + pad)));
        return JSON.parse(json);
      } catch { return null; }
    }

    // ---------- Charts ----------
    let scoresChart = null;
    const smallCharts = []; // keep references to destroy/redraw

    function clearCharts() {
      if (scoresChart) { scoresChart.destroy(); scoresChart = null; }
      smallCharts.splice(0).forEach(ch => ch.destroy());
      document.getElementById('subelementGrid').innerHTML = '';
      document.getElementById('groupGrid').innerHTML = '';
    }

    function renderScoresOverTime(history) {
      const ctx = document.getElementById('scoresOverTime').getContext('2d');
      const labels = history.map(h => new Date(h.ts).toLocaleString());
      const data   = history.map(h => h.scorePct);
      scoresChart = new Chart(ctx, {
        type: 'bar',
        data: { labels, datasets: [{ label: 'Test Score (%)', data }] },
        options: { responsive: true, scales: { y: { beginAtZero: true, max: 100 } } }
      });
    }

    // Small stacked bar: green (correct) bottom, red (wrong) top
    function addStackedBar(parent, title, correct, wrong) {
      const wrap = document.createElement('div');
      wrap.className = 'chart-card';
      const h = document.createElement('div');
      h.className = 'chart-title';
      h.textContent = `${title}`;
      const canvas = document.createElement('canvas');
      canvas.height = 110; // compact
      wrap.appendChild(h);
      wrap.appendChild(canvas);
      parent.appendChild(wrap);

      const chart = new Chart(canvas.getContext('2d'), {
        type: 'bar',
        data: {
          labels: [''],
          datasets: [
            { label: 'Correct', data: [correct], stack: 's', backgroundColor: '#0a7b34' },
            { label: 'Wrong',   data: [wrong],   stack: 's', backgroundColor: '#b00020' }
          ]
        },
        options: {
          responsive: true,
          plugins: {
            legend: { display: false },
            tooltip: {
              callbacks: {
                footer: (items) => {
                  // Show totals in tooltip footer
                  const total = correct + wrong;
                  return `Total: ${total}`;
                }
              }
            }
          },
          scales: {
            x: { stacked: true, ticks: { display: false }, grid: { display: false }, border: { display: false } },
            y: { stacked: true, beginAtZero: true, ticks: { display: false }, grid: { display: false }, border: { display: false } }
          }
        }
      });
      smallCharts.push(chart);
    }

    function renderSubelementStacks(subStats) {
      const grid = document.getElementById('subelementGrid');
      const keys = Object.keys(subStats).sort((a,b)=>parseInt(a.slice(1))-parseInt(b.slice(1)));
      keys.forEach(k => {
        const {correct=0, wrong=0} = subStats[k] || {};
        addStackedBar(grid, k, correct, wrong);
      });
    }

    function renderGroupStacks(groupStats) {
      const container = document.getElementById('groupGrid');
      container.innerHTML = '';
      const subs = Object.keys(groupStats).sort((a,b)=>parseInt(a.slice(1))-parseInt(b.slice(1)));

      subs.forEach(sub => {
        const section = document.createElement('section');
        section.className = 'sub-section';
        const h = document.createElement('h4');
        h.textContent = `Groups in ${sub}`;
        section.appendChild(h);

        const grid = document.createElement('div');
        grid.className = 'grid10';

        const groups = Object.keys(groupStats[sub]).sort();
        groups.forEach(g => {
          const {correct=0, wrong=0} = groupStats[sub][g] || {};
          addStackedBar(grid, g, correct, wrong);
        });

        section.appendChild(grid);
        container.appendChild(section);
      });
    }

    function renderAllCharts(stats) {
      clearCharts();
      renderScoresOverTime(stats.history || []);
      renderSubelementStacks(stats.subelements || {});
      renderGroupStacks(stats.groups || {});
    }

    // ---------- App state ----------
    const state = {
      all: [],
      selected: [],
      answered: new Map(),
      presentedIds: [],
      correctIds: new Set(),
      wrongIds: new Set(),
      done: false,
      stats: {
        history: [],       // [{ts, scorePct}]
        subelements: {},   // { E1:{correct,wrong}, ... }
        groups: {}         // { E1:{ A:{correct,wrong}, ... }, ... }
      }
    };

    // ---------- Loaders ----------
    async function loadFromFetch() {
      const res = await fetch('extra_pool.json', { cache: 'no-store' });
      if (!res.ok) throw new Error(`Failed to fetch extra_pool.json (${res.status})`);
      return res.json();
    }
    function loadFromFile(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onerror = () => reject(reader.error);
        reader.onload = () => {
          try { resolve(JSON.parse(reader.result)); } catch (e) { reject(e); }
        };
        reader.readAsText(file);
      });
    }

    // ---------- Exam logic ----------
    function buildExam(questions) {
      const buckets = new Map();
      for (const q of questions) {
        const key = groupKey(q);
        if (!buckets.has(key)) buckets.set(key, []);
        buckets.get(key).push(q);
      }
      const chosen = [];
      for (const [, arr] of buckets.entries()) chosen.push(pickRandom(arr));
      chosen.sort((a,b) => {
        const an = parseInt(a.subelement,10), bn = parseInt(b.subelement,10);
        if (an !== bn) return an - bn;
        return a.group_index.localeCompare(b.group_index);
      });
      return chosen;
    }

    function renderExam() {
      const container = document.getElementById('exam');
      container.innerHTML = "";
      state.answered.clear();
      state.correctIds.clear();
      state.wrongIds.clear();
      state.done = false;
      state.presentedIds = state.selected.map(q => q.id);

      for (const q of state.selected) {
        const card = document.createElement('div');
        card.className = 'card';

        const header = document.createElement('div');
        header.className = 'qid';
        header.textContent = `E${q.subelement}${q.group_index}${q.group_number} (id ${q.id})`;
        card.appendChild(header);

        const qtext = document.createElement('div');
        qtext.className = 'qtext';
        qtext.textContent = sanitize(q.question);
        card.appendChild(qtext);

        const controls = document.createElement('div');
        controls.className = 'controls';

        const select = document.createElement('select');
        select.innerHTML = `<option value="">-- choose an answer --</option>`;
        ['A','B','C','D'].forEach(letter => {
          const field = letterToField(letter);
          const txt = sanitize(q[field]);
          if (!txt) return;
          const opt = document.createElement('option');
          opt.value = letter;
          opt.textContent = `${letter}. ${txt}`;
          select.appendChild(opt);
        });

        const btn = document.createElement('button');
        btn.className = 'btn';
        btn.textContent = 'Submit answer';

        const result = document.createElement('div');
        result.className = 'result';

        btn.addEventListener('click', () => {
          if (!select.value) { alert('Please choose an answer first.'); return; }
          if (select.disabled) return;

          const chosenLetter = select.value;
          const correctLetter = (q.answer || '').trim().toUpperCase();
          const isCorrect = chosenLetter === correctLetter;

          state.answered.set(q.id, { selected: chosenLetter, correct: isCorrect });

          const correctField = letterToField(correctLetter);
          const correctText = sanitize(correctField ? q[correctField] : "");
          if (isCorrect) {
            result.textContent = 'Correct answer';
            result.classList.remove('incorrect');
            result.classList.add('correct');
            state.correctIds.add(q.id);
          } else {
            result.textContent = `Incorrect. The correct answer was: ${correctText || correctLetter}`;
            result.classList.remove('correct');
            result.classList.add('incorrect');
            state.wrongIds.add(q.id);
          }

          select.disabled = true;
          btn.disabled = true;

          if (state.answered.size === state.selected.length && !state.done) {
            state.done = true;
            finalizeTestAndRender();
          }
        });

        controls.appendChild(select);
        controls.appendChild(btn);
        card.appendChild(controls);
        card.appendChild(result);
        container.appendChild(card);
      }
    }

    function finalizeTestAndRender() {
      const total = state.selected.length;
      const correct = state.correctIds.size;
      const pct = Math.round((correct / total) * 100);
      const pass = pct >= 80;

      const summary = document.getElementById('summary');
      const scoreLine = document.getElementById('scoreLine');
      scoreLine.textContent = pass
        ? `You passed with ${pct}% (${correct}/${total} correct).`
        : `You failed with ${pct}% (${correct}/${total} correct).`;

      const tracking = {
        presented_question_ids: state.presentedIds,
        correct_question_ids: Array.from(state.correctIds),
        wrong_question_ids: Array.from(state.wrongIds)
      };
      document.getElementById('tracking').textContent = JSON.stringify(tracking, null, 2);
      summary.hidden = false;

      accumulateStatsFromCurrentTest();
      state.stats.history.push({ ts: nowIso(), scorePct: pct });

      renderAllCharts(state.stats);
      document.getElementById('newExamBtn').disabled = false;
      window.scrollTo({ top: document.getElementById('charts').offsetTop, behavior: 'smooth' });
    }

    function accumulateStatsFromCurrentTest() {
      for (const q of state.selected) {
        const keySub = `E${q.subelement}`;
        const keyGrp = q.group_index;
        const wasCorrect = state.correctIds.has(q.id);

        if (!state.stats.subelements[keySub]) state.stats.subelements[keySub] = { correct:0, wrong:0 };
        state.stats.subelements[keySub][wasCorrect ? 'correct':'wrong']++;

        if (!state.stats.groups[keySub]) state.stats.groups[keySub] = {};
        if (!state.stats.groups[keySub][keyGrp]) state.stats.groups[keySub][keyGrp] = { correct:0, wrong:0 };
        state.stats.groups[keySub][keyGrp][wasCorrect ? 'correct':'wrong']++;
      }
    }

    function startNewExam(questions) {
      state.selected = buildExam(questions);
      document.getElementById('summary').hidden = true;
      renderExam();
    }

    // ---------- Hash state (persist across runs) ----------
    function updateHashWithStats() {
      const encoded = encodeState(state.stats);
      const url = location.origin + location.pathname + '#c=' + encoded;
      location.assign(url);
    }

    function restoreStatsFromHash() {
      const m = location.hash.match(/^#c=([^&]+)/);
      if (!m) return false;
      const data = decodeState(m[1]);
      if (!data) return false;
      state.stats.history     = Array.isArray(data.history) ? data.history : [];
      state.stats.subelements = typeof data.subelements === 'object' && data.subelements ? data.subelements : {};
      state.stats.groups      = typeof data.groups === 'object' && data.groups ? data.groups : {};
      renderAllCharts(state.stats);
      return true;
    }

    // ---------- UI wiring ----------
    document.getElementById('loadBtn').addEventListener('click', async () => {
      try {
        state.all = await loadFromFetch();
        startNewExam(state.all);
        document.getElementById('newExamBtn').disabled = false;
      } catch (e) {
        alert(`Could not load extra_pool.json: ${e.message}`);
      }
    });

    document.getElementById('fileInput').addEventListener('change', async (ev) => {
      const file = ev.target.files?.[0];
      if (!file) return;
      try {
        state.all = await loadFromFile(file);
        startNewExam(state.all);
        document.getElementById('newExamBtn').disabled = false;
      } catch (e) {
        alert(`Could not read JSON file: ${e.message}`);
      }
    });

    document.getElementById('newExamBtn').addEventListener('click', () => {
      updateHashWithStats();          // persist cumulative stats in URL
      if (state.all.length) startNewExam(state.all); // build next exam without reload
    });

    // On first load: if hash has #c=..., restore and render charts
    restoreStatsFromHash();
  </script>
</body>
</html>
