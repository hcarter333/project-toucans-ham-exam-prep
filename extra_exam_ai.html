<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Extra Class Practice Exam + AI Help</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.4/dist/chart.umd.min.js"></script>
  <style>
    :root { font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; }
    body { margin: 2rem; }
    h1 { margin-top: 0; }
    .toolbar { display:flex; gap:.5rem; align-items:center; margin-bottom:1rem; flex-wrap:wrap;}
    .btn { cursor:pointer; padding:.5rem .75rem; border:1px solid #ccc; border-radius:.5rem; background:#f7f7f7; }
    .btn:disabled { opacity:.6; cursor:not-allowed; }
    .muted { color:#777; font-size:.9rem; }
    .card { border:1px solid #e5e5e5; border-radius:12px; padding:1rem; margin:1rem 0; box-shadow:0 1px 3px rgba(0,0,0,.05); }
    .qid { font-weight:600; color:#555; margin-bottom:.25rem; }
    .qtext { margin:.25rem 0 .5rem; line-height:1.5; }
    .figure { margin:.25rem 0 .75rem; }
    .figure img { max-width:100%; height:auto; border:1px solid #eee; border-radius:8px; }
    .controls { display:flex; gap:.5rem; align-items:center; flex-wrap:wrap; }
    select { padding:.4rem .5rem; max-width: 100%; white-space: normal; }

    .result { margin-top:.5rem; font-weight:600; }
    .correct { color:#0a7b34; }
    .incorrect { color:#b00020; }

    #summary { margin-top:2rem; padding:1rem; border:2px dashed #ddd; border-radius:12px; background:#fafafa; }

    #charts { margin-top:2rem; }
    .section-title { margin-top:2rem; margin-bottom:.5rem; }
    .charts-note { color:#555; font-size:.9rem; margin-bottom:.5rem; }

    .grid10 { display:grid; grid-template-columns: repeat(10, minmax(80px, 1fr)); gap: 8px; align-items:start; }
    .chart-card { border:1px solid #eee; border-radius:12px; padding:8px; }
    .chart-title-row { display:flex; align-items:center; justify-content:space-between; gap:6px; margin-bottom:6px; }
    .chart-title { font-weight:600; font-size:.9rem; margin:0; }
    .caret-btn { cursor:pointer; border:1px solid #ddd; background:#fafafa; border-radius:6px; padding:2px 6px; line-height:1; }
    .caret-btn[hidden] { display:none; }
    #groupDetails { margin-top: 10px; }
    .sub-section { margin-top: 12px; }

/* --- Per-question AI help UI --- */
/* --- Per-question AI help UI --- */
.ai-help-row {
  display: flex;
  gap: 0.5rem;
  align-items: center;
  margin-top: 0.5rem;
}

.ai-follow-input {
  flex: 1;
  min-width: 200px;
  padding: 0.5rem 0.6rem;
  border: 1px solid #ccc;
  border-radius: 0.5rem;
}

.ai-help-btn {
  padding: 0.5rem 0.75rem;
  border: 1px solid #ccc;
  border-radius: 0.5rem;
  background: #0066cc;
  color: #fff;
  cursor: pointer;
  transition: background 0.2s;
}
.ai-help-btn:hover { background: #0055aa; }

/* --- AI response box --- */
.ai-box {
  margin-top: 0.5rem;
  border: 1px solid #ddd;
  border-radius: 10px;
  background: #fafafa;
  padding: 0.75rem 1rem;
}

/* Markdown-style rich text output */
.ai-log {
  width: 100%;
  min-height: 140px;
  max-height: 65vh;
  overflow: auto;
  resize: vertical;
  font-family: system-ui, -apple-system, 'Segoe UI', Roboto, sans-serif;
  line-height: 1.5;
  color: #222;
  white-space: normal;
}

/* Headings, bold, italic */
.ai-log strong { font-weight: 600; }
.ai-log em { font-style: italic; }

/* Lists */
.ai-log ul, .ai-log ol {
  margin: 0.4em 0 0.4em 1.5em;
  padding: 0;
}
.ai-log li { margin-bottom: 0.25em; }

/* Code and preformatted */
.ai-log code {
  font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
  background: #f0f0f0;
  border-radius: 4px;
  padding: 2px 4px;
}
.ai-log pre {
  background: #f6f8fa;
  padding: 0.75em;
  border-radius: 6px;
  overflow-x: auto;
  font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
}

/* Horizontal rule and blockquote */
.ai-log hr {
  border: none;
  border-top: 1px solid #ddd;
  margin: 0.75em 0;
}
.ai-log blockquote {
  border-left: 4px solid #ccc;
  margin: 0.5em 0;
  padding-left: 0.75em;
  color: #555;
  background: #fdfdfd;
}

/* Tables */
.ai-log table {
  border-collapse: collapse;
  width: 100%;
  margin: 0.75em 0;
}
.ai-log th, .ai-log td {
  border: 1px solid #ccc;
  padding: 4px 8px;
}
.ai-log th { background: #f0f0f0; text-align: left; }
    .openai-chatkit {
      display: block;
      height: 100vh;
      width: 100%;
    }

  </style>
</head>
<script src="https://cdn.jsdelivr.net/npm/dompurify@3.1.7/dist/purify.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/marked@12.0.2/marked.min.js"></script>
<script src="https://cdn.platform.openai.com/deployments/chatkit/chatkit.js" async></script>

<!-- MathJax v3 config: must be defined BEFORE the script tag -->
<script>
window.MathJax = {
  tex: {
    inlineMath: [['$', '$'], ['\\(', '\\)']],
    displayMath: [['$$', '$$'], ['\\[', '\\]']],
    processEscapes: true
  },
  options: {
      // Only process math inside normal content
    },
  startup: {
    typeset: true
  }

  };
</script>
<script async id="MathJax-script"
        src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
        
        
<body>
  <h1>Extra Class Practice Exam</h1>
  <openai-chatkit id="chat"></openai-chatkit>

  <div class="toolbar">
    <button id="newExamBtn" class="btn" disabled>New exam</button>
  </div>

  <div id="charts">
    <h2 class="section-title">Performance Dashboard</h2>
    <div class="charts-note">Cumulative charts and score history (persisted via <code>#c=...</code> in the URL).</div>

    <div class="chart-card" style="margin-bottom:12px;">
      <canvas id="scoresOverTime" height="140"></canvas>
    </div>

    <h3 class="section-title">Correct vs Wrong by Subelement</h3>
    <div id="subelementGrid" class="grid10"></div>
    <div id="groupDetails"></div>
  </div>

  <div id="exam"></div>

  <div id="summary" hidden>
    <h2>Your Score</h2>
    <p id="scoreLine"></p>
    <details>
      <summary>What was tracked? (this test)</summary>
      <pre id="tracking" style="white-space:pre-wrap;"></pre>
    </details>
  </div>

  <script>
// Optional but helpful: preserve backslashes/ids and respect single line breaks
if (window.marked) {
  marked.setOptions({
    mangle: false,
    headerIds: false,
    breaks: true
  });
}

    /* =========================
       OpenAI Retrieval Plumbing
    ========================= */
    const BASE = "https://api.openai.com/v1";
    const QUESTION_POOL_URL =
      "https://raw.githubusercontent.com/hcarter333/project-toucans-ham-exam-prep/refs/heads/main/extra_pool.json";

    // System prompt required by spec
/*    const system_prompt =
`You are a careful ham-radio tutor. Use the File Search knowledge base (extra_pool.json).
When a question id is provided, locate that record and:
1) State the correct letter and the correct text.
2) Explain why it's correct, step-by-step.
3) Briefly say why the other options are incorrect.
If no evidence is found, respond with NOT_FOUND.`
*/
const system_prompt = `
You are a ham radio license exam tutor for the U.S. Extra Class exam. 
Be calm, clear, and encouraging. Assume the student is not an engineer. 
Ask gentle follow-up questions. When an exam question involves math 
or numbers, always work out the math in a step by step fashion, explaining 
why each step wwas taken. NEVER USE THE PHRASE "DON'T WORRY".

NEVER contradict the correct answewr as 
demarked with the  ✅ symbol.

When giving equations or math expressions:

FORMAT RULES (CRITICAL)
-----------------------
1. Use $...$ for inline math.
2. Use $$...$$ for display (block) math.
3. DO NOT use \\(, \\), \\[ or \\].
4. Output Markdown that renders correctly in MathJax with $ delimiters only.
-----------------------

Return Markdown only—no HTML or explanations of formatting.

`;


    function getAPIKey() {
      let apiKey = localStorage.getItem('openai_api_key');
      if (!apiKey) {
        apiKey = prompt('Enter your OpenAI API Key:');
        if (apiKey) localStorage.setItem('openai_api_key', apiKey);
      }
      return apiKey;
    }

    async function openai(path, { method = 'POST', headers = {}, body } = {}) {
      const apiKey = getAPIKey();
      if (!apiKey) throw new Error('Missing OpenAI API key.');

      const isForm = (body instanceof FormData);
      const res = await fetch(`${BASE}${path}`, {
        method,
        headers: isForm
          ? { 'Authorization': `Bearer ${apiKey}`, ...headers }
          : { 'Authorization': `Bearer ${apiKey}`, 'Content-Type': 'application/json', ...headers },
        body: isForm ? body : (body ? JSON.stringify(body) : undefined),
      });

      const text = await res.text();
      if (!res.ok) throw new Error(`OpenAI ${path} failed: ${res.status} ${res.statusText} :: ${text}`);
      return text ? JSON.parse(text) : {};
    }

    async function openaick(path, { method = 'POST', headers = {}, body } = {}) {
      const apiKey = getAPIKey();
      if (!apiKey) throw new Error('Missing OpenAI API key.');

      const isForm = (body instanceof FormData);
      const res = await fetch(`${BASE}${path}`, {
        method,
        headers: isForm
          ? { 'Authorization': `Bearer ${apiKey}`, ...headers }
          : { "OpenAI-Beta": "chatkit_beta=v1", 'Authorization': `Bearer ${apiKey}`, 'Content-Type': 'application/json', ...headers },
        body: isForm ? body : (body ? JSON.stringify(body) : undefined),
      });

      const text = await res.text();
      if (!res.ok) throw new Error(`OpenAI ${path} failed: ${res.status} ${res.statusText} :: ${text}`);
      return text ? JSON.parse(text) : {};
    }

    async function ensureVectorStore(jsonData) {
      let vsId = localStorage.getItem('vector_store_id');
      if (vsId) return vsId;

      const vs = await openai('/vector_stores', { body: { name: 'Ham Exam Pool (User-Owned)' } });
      vsId = vs.id;

      const form = new FormData();
      const blob = new Blob([JSON.stringify(jsonData, null, 2)], { type: 'application/json' });
      form.append('file', blob, 'extra_pool.json');
      form.append('purpose', 'assistants');
      const file = await openai('/files', { body: form });

      await openai(`/vector_stores/${vsId}/files`, { body: { file_id: file.id } });
      await waitForFileReady(vsId, file.id);

      localStorage.setItem('vector_store_id', vsId);
      return vsId;
    }

    async function waitForFileReady(vectorStoreId, fileId, timeoutMs = 30000) {
      const start = Date.now();
      while (true) {
        const status = await openai(`/vector_stores/${vectorStoreId}/files/${fileId}`, { method: 'GET' });
        if (status.status === 'completed') return;
        if (status.status === 'failed') throw new Error('Vector store indexing failed');
        if (Date.now() - start > timeoutMs) throw new Error('Timed out waiting for indexing');
        await new Promise(r => setTimeout(r, 900));
      }
    }

    // Extract assistant text from Responses payload
    function extractText(resp) {
      if (resp && Array.isArray(resp.output)) {
        for (const msg of resp.output) {
          if (msg.type === 'message' && msg.status === 'completed' && Array.isArray(msg.content)) {
            const hit = msg.content.find(c => c.type === 'output_text' && typeof c.text === 'string');
            if (hit) return hit.text;
          }
        }
      }
      return null;
    }

    function extractTextck(resp) {
      if (resp && resp.status == "active") {
        const hit = resp.client_secret;
        return hit;
      }
      return null;
    }

    // Per-question conversation state (persisted)
    function loadThreads() {
      try { return JSON.parse(localStorage.getItem('ai_threads4') || '{}'); }
      catch { return {}; }
    }
    function saveThreads(obj) {
      localStorage.setItem('ai_threads4', JSON.stringify(obj));
    }
    let AI_THREADS = loadThreads(); // { [qid]: { history:[{role,content}], panel:"", ckthread:obj } }

    // Send turn via Responses + File Search, using per-question thread
    async function askAI({ qid, followup }) {
      const vsId = localStorage.getItem('vector_store_id');
      //if (!vsId) throw new Error('No vector_store_id found.');

      if (!AI_THREADS[qid]) AI_THREADS[qid] = { history: [], panel: "",  ckthread: null };

      // Compose system + history + user
      const sys = `${system_prompt}`;
      const messages = [{ role: 'system', content: sys }];
      for (const m of AI_THREADS[qid].history) messages.push(m);
      let roleStr = "";
      if(!(followup && followup.trim())){
        roleStr = 'assistant';
      }else{
        roleStr = 'user';
      }
      
      const userMsg = (followup && followup.trim()) ?
          followup.trim() :
          `Please help me with ${getQuestionMarkdown(qid)}`;
      
      messages.push({ role: roleStr, content: userMsg });

      const resp = await openai('/responses', {
        body: {
          model: 'gpt-4.1-mini',
          input: messages,
          prompt_cache_key: "extra-class-tutor-v3",
          //tools: [{ type: 'file_search', vector_store_ids: [vsId] }],
          truncation: "auto"
        }
      });
      const answer = extractText(resp) || "(no answer text)";


      // update thread + panel
      AI_THREADS[qid].history.push({ role:'user', content:userMsg });
      AI_THREADS[qid].history.push({ role:'assistant', content:answer });

      const block = `Q#${qid} — ${userMsg}\n${answer}\n`;
      AI_THREADS[qid].panel = (AI_THREADS[qid].panel ? AI_THREADS[qid].panel + "\n" : "") + block;
      saveThreads(AI_THREADS);



        //wwe resume our normal showw

      return { userMsg, answer, panelText: AI_THREADS[qid].panel };
    }

    let client_key = "";

    async function getChatKey(){
        const respck = await openaick('/chatkit/sessions', {
          body: {
            workflow: { id: "wf_68e55e0c05a0819099112be4a1f8f3f307c0b7f1fed4ccb0" },
            user: "testdevice",
          }
        });
        
        const client_key = extractTextck(respck);

        console.log("printing client_key");
        console.log(client_key);
        return client_key
    }

    async function askCKAI(qid, el){
      //let's see if we can also get a chatkit key
   //now try to use chatkit
  //modifyf this to also start the per question version
  //Set it up if you haven't already
      let threadId = null;

  if (!AI_THREADS[qid]) AI_THREADS[qid] = { history: [], panel: "",  ckthread: null };

  if(AI_THREADS[qid].ckthread == null){

      el.addEventListener("chatkit.thread.change", (e) => {
        threadId = e.detail.threadId;
        console.log("Thread created:", threadId);
        AI_THREADS[qid].ckthread = threadId;
      });    
      

      //const el = document.getElementById("chat");
      await el.setOptions({
        api: { getClientSecret: getChatKey },
        theme: "light",
        header: { enabled: true, title: { text: "Ham Radio Exam Help" } },
        composer: { placeholder: "Any followups?" },
        initialThread: null,
      });

      await Promise.resolve();
      
      
  }



  el.addEventListener("chatkit.response.end", () => {
    if (window.MathJax?.typesetPromise) {
      MathJax.typesetPromise();
    }
  });

  console.log("sending initial message");
      // Send the initial message immediately
    await el.sendUserMessage({
      text: `Please help me with ${getQuestionMarkdown(qid)}`
    });


el.addEventListener("chatkit.error", async (e) => {
    const err = e.detail?.error;
    const status = err?.status || err?.cause?.status || err?.response?.status;
    if (status === 401) {
      // Invalidate & refresh
      client_key = "";
        const respck = await openaick('/chatkit/sessions', {
          body: {
            workflow: { id: "wf_68e55e0c05a0819099112be4a1f8f3f307c0b7f1fed4ccb0" },
            user: "testdevice",
          }
        });

        client_key = extractTextck(respck);

      try {
        //await fetchNewClientSecret();
        // Nudge UI to pull fresh data (optional)
        await el.fetchUpdates();
      } catch (refreshErr) {
        console.error("Failed to refresh client_secret after 401:", refreshErr);
      }
    }
  });     

    }

    /* =========================
       Exam App (your code, + AI UI)
    ========================= */
    const FIG_BASE_URL = "https://raw.githubusercontent.com/hcarter333/project-toucans-ham-exam-prep/refs/heads/main/img/";
    function groupKey(q) { return `E${q.subelement}${q.group_index}`; }
    function subKey(q)   { return `E${q.subelement}`; }
    function pickRandom(arr) { return arr[Math.floor(Math.random() * arr.length)]; }
    function letterToField(letter) {
      const map = { A: "answer_a", B: "answer_b", C: "answer_c", D: "answer_d" };
      return map[letter] || null;
    }
    function sanitize(text) { return (text ?? "").toString().replace(/\s+/g, " ").trim(); }
    const nowIso = () => new Date().toISOString();

    function findFigureSlug(text) {
      if (!text) return null;
      const re = /Figure\s+([A-Za-z])\s*([0-9]+)\s*[-–—]\s*([0-9]+)/i;
      const m = text.match(re);
      if (!m) return null;
      const letter = m[1].toLowerCase();
      const major  = m[2];
      const minor  = m[3];
      return `${letter}${major}-${minor}`;
    }

    function encodeState(obj) {
      const json = JSON.stringify(obj);
      const b64 = btoa(unescape(encodeURIComponent(json)));
      return b64.replace(/\+/g,'-').replace(/\//g,'_').replace(/=+$/,'');
    }
    function decodeState(s) {
      try {
        const b64 = s.replace(/-/g,'+').replace(/_/g,'/');
        const pad = b64.length % 4 ? '='.repeat(4 - (b64.length % 4)) : '';
        const json = decodeURIComponent(escape(atob(b64 + pad)));
        return JSON.parse(json);
      } catch { return null; }
    }

    let scoresChart = null;
    const subelementCharts = [];
    const groupCharts = [];
    let currentExpandedSub = null;

    function destroyCharts(arr) { while (arr.length) { try { arr.pop().destroy(); } catch {} } }
    function clearCharts() {
      if (scoresChart) { try { scoresChart.destroy(); } catch {} scoresChart = null; }
      destroyCharts(subelementCharts);
      destroyCharts(groupCharts);
      document.getElementById('subelementGrid').innerHTML = '';
      document.getElementById('groupDetails').innerHTML = '';
      currentExpandedSub = null;
    }

    function renderScoresOverTime(history) {
      const ctx = document.getElementById('scoresOverTime').getContext('2d');
      const labels = history.map(h => new Date(h.ts).toLocaleString());
      const data   = history.map(h => h.scorePct);
      scoresChart = new Chart(ctx, {
        type: 'bar',
        data: { labels, datasets: [{ label: 'Test Score (%)', data }] },
        options: { responsive: true, scales: { y: { beginAtZero: true, max: 100 } } }
      });
    }

    function createStackedBar(canvas, correct, wrong) {
      return new Chart(canvas.getContext('2d'), {
        type: 'bar',
        data: {
          labels: [''],
          datasets: [
            { label: 'Correct', data: [correct], stack: 's', backgroundColor: '#0a7b34' },
            { label: 'Wrong',   data: [wrong],   stack: 's', backgroundColor: '#b00020' }
          ]
        },
        options: {
          responsive: true,
          plugins: { legend: { display:false } },
          scales: {
            x: { stacked:true, ticks:{display:false}, grid:{display:false}, border:{display:false} },
            y: { stacked:true, beginAtZero:true, ticks:{display:false}, grid:{display:false}, border:{display:false} }
          }
        }
      });
    }

    function renderSubelementStacks(subStats, groupsStats) {
      const grid = document.getElementById('subelementGrid');
      grid.innerHTML = '';
      destroyCharts(subelementCharts);

      const subs = Object.keys(subStats).sort((a,b)=>parseInt(a.slice(1))-parseInt(b.slice(1)));
      subs.forEach(sub => {
        const {correct=0, wrong=0} = subStats[sub] || {};
        const card = document.createElement('div');
        card.className = 'chart-card';

        const row = document.createElement('div');
        row.className = 'chart-title-row';

        const title = document.createElement('div');
        title.className = 'chart-title';
        title.textContent = `${sub}`;

        const caret = document.createElement('button');
        caret.className = 'caret-btn';
        caret.innerHTML = (currentExpandedSub === sub) ? '&#9650;' : '&#9660;';

        const hasGroups = !!(groupsStats && groupsStats[sub] && Object.keys(groupsStats[sub]).length);
        if (!hasGroups) caret.hidden = true;

        caret.addEventListener('click', () => {
          if (currentExpandedSub === sub) {
            currentExpandedSub = null;
            caret.innerHTML = '&#9660;';
            document.getElementById('groupDetails').innerHTML = '';
            destroyCharts(groupCharts);
            Array.from(document.querySelectorAll('.caret-btn')).forEach(btn => { if (!btn.hidden) btn.innerHTML = '&#9660;'; });
          } else {
            currentExpandedSub = sub;
            Array.from(document.querySelectorAll('.caret-btn')).forEach(btn => { if (!btn.hidden) btn.innerHTML = '&#9660;'; });
            caret.innerHTML = '&#9650;';
            renderGroupStacksForSub(sub);
          }
        });

        row.appendChild(title);
        row.appendChild(caret);
        card.appendChild(row);

        const canvas = document.createElement('canvas');
        canvas.height = 110;
        card.appendChild(canvas);
        grid.appendChild(card);

        const chart = createStackedBar(canvas, correct, wrong);
        subelementCharts.push(chart);
      });
    }

    function renderGroupStacksForSub(sub) {
      const holder = document.getElementById('groupDetails');
      holder.innerHTML = '';
      destroyCharts(groupCharts);

      const section = document.createElement('section');
      section.className = 'sub-section';

      const h = document.createElement('h4');
      h.textContent = `Groups in ${sub}`;
      section.appendChild(h);

      const grid = document.createElement('div');
      grid.className = 'grid10';

      const groupsObj = state.stats.groups[sub] || {};
      const groups = Object.keys(groupsObj).sort();

      groups.forEach(g => {
        const {correct=0, wrong=0} = groupsObj[g] || {};
        const card = document.createElement('div');
        card.className = 'chart-card';

        const row = document.createElement('div');
        row.className = 'chart-title-row';

        const title = document.createElement('div');
        title.className = 'chart-title';
        title.textContent = `${sub}${g}`;

        row.appendChild(title);
        card.appendChild(row);

        const canvas = document.createElement('canvas');
        canvas.height = 110;
        card.appendChild(canvas);
        grid.appendChild(card);

        const chart = createStackedBar(canvas, correct, wrong);
        groupCharts.push(chart);
      });

      section.appendChild(grid);
      holder.appendChild(section);
    }

    function renderAllCharts(stats) {
      clearCharts();
      renderScoresOverTime(stats.history || []);
      renderSubelementStacks(stats.subelements || {}, stats.groups || {});
    }

    const state = {
      all: [],
      selected: [],
      answered: new Map(),
      presentedIds: [],
      correctIds: new Set(),
      wrongIds: new Set(),
      done: false,
      stats: { history: [], subelements: {}, groups: {} }
    };

    async function loadPool() {
      const res = await fetch(QUESTION_POOL_URL);
      if (!res.ok) throw new Error(`HTTP ${res.status}`);
      return res.json();
    }

    function buildExam(questions) {
      const buckets = new Map();
      for (const q of questions) {
        const key = groupKey(q);
        if (!buckets.has(key)) buckets.set(key, []);
        buckets.get(key).push(q);
      }
      const chosen = [];
      for (const [, arr] of buckets.entries()) chosen.push(pickRandom(arr));
      chosen.sort((a,b) => {
        const an = parseInt(a.subelement,10), bn = parseInt(b.subelement,10);
        if (an !== bn) return an - bn;
        return a.group_index.localeCompare(b.group_index);
      });
      return chosen;
    }

    function renderExam() {
      const container = document.getElementById('exam');
      container.innerHTML = "";
      state.answered.clear();
      state.correctIds.clear();
      state.wrongIds.clear();
      state.done = false;
      state.presentedIds = state.selected.map(q => q.id);

      for (const q of state.selected) {
        const card = document.createElement('div');
        card.className = 'card';

        const header = document.createElement('div');
        header.className = 'qid';
        header.textContent = `E${q.subelement}${q.group_index}${q.group_number} (id ${q.id})`;
        card.appendChild(header);

        const qtext = document.createElement('div');
        qtext.className = 'qtext';
        const qTextStr = sanitize(q.question);
        qtext.textContent = qTextStr;
        card.appendChild(qtext);

        const slug = findFigureSlug(qTextStr);
        if (slug) {
          const figDiv = document.createElement('div');
          figDiv.className = 'figure';
          const img = document.createElement('img');
          img.loading = 'lazy';
          img.alt = `Figure ${slug.toUpperCase()}`;
          img.src = FIG_BASE_URL + `${slug}.png`;
          img.onerror = () => { figDiv.remove(); };
          figDiv.appendChild(img);
          card.appendChild(figDiv);
        }

        const controls = document.createElement('div');
        controls.className = 'controls';

        const select = document.createElement('select');
        select.innerHTML = `<option value="">-- choose an answer --</option>`;
        ['A','B','C','D'].forEach(letter => {
          const field = letterToField(letter);
          const txt = sanitize(q[field]);
          if (!txt) return;
          const opt = document.createElement('option');
          opt.value = letter;
          opt.textContent = `${letter}. ${txt}`;
          select.appendChild(opt);
        });

        const btn = document.createElement('button');
        btn.className = 'btn';
        btn.textContent = 'Submit answer';

        const result = document.createElement('div');
        result.className = 'result';

        btn.addEventListener('click', () => {
          if (!select.value) { alert('Please choose an answer first.'); return; }
          if (select.disabled) return;

          const chosenLetter = select.value;
          const correctLetter = (q.answer || '').trim().toUpperCase();
          const isCorrect = chosenLetter === correctLetter;

          state.answered.set(q.id, { selected: chosenLetter, correct: isCorrect });

          const correctField = letterToField(correctLetter);
          const correctText = sanitize(correctField ? q[correctField] : "");
          if (isCorrect) {
            result.textContent = 'Correct answer';
            result.classList.remove('incorrect');
            result.classList.add('correct');
            state.correctIds.add(q.id);
          } else {
            result.textContent = `Incorrect. The correct answer was: ${correctText || correctLetter}`;
            result.classList.remove('correct');
            result.classList.add('incorrect');
            state.wrongIds.add(q.id);
          }

          select.disabled = true;
          btn.disabled = true;

          if (state.answered.size === state.selected.length && !state.done) {
            state.done = true;
            finalizeTestAndRender();
          }
        });

        controls.appendChild(select);
        controls.appendChild(btn);
        card.appendChild(controls);
        card.appendChild(result);

// --------- Per-question AI help UI (hidden until first click) ---------
const aiRow = document.createElement('div');
aiRow.className = 'ai-help-row';


// follow-up input is created now but hidden until first AI help click
//const followupInput = document.createElement('input');
//followupInput.type = 'text';
//followupInput.placeholder = 'Ask a follow-up (optional)…';
//followupInput.className = 'ai-follow-input';
//followupInput.hidden = true;  // <- per your requirement

// AI help button (always visible)
const helpBtn = document.createElement('button');
helpBtn.type = 'button';
helpBtn.className = 'ai-help-btn';
helpBtn.textContent = 'AI help';

// resizable answer box for this question (hidden by default)
const aiBox = document.createElement('div');
aiBox.className = 'ai-box';
aiBox.hidden = true;

const aiCk = document.createElement('openai-chatkit');
aiCk.className = 'openai-chatkit';
aiCk.hidden = true;

const aiLog = document.createElement('div');
aiLog.className = 'ai-log';
aiLog.hidden = true;              // keep hidden until first click
aiLog.innerHTML = '';             // will hold rendered HTML
aiBox.appendChild(aiLog);
aiBox.appendChild(aiCk);

// If we already have history for this q.id, preload it (but keep hidden until first click)
if (AI_THREADS[q.id] && Array.isArray(AI_THREADS[q.id]) && AI_THREADS[q.id].length) {
  aiLog.innerHTML = aiLog.innerHTML = DOMPurify.sanitize(marked.parse(AI_THREADS[q.id].join('\n') + '\n'));
}

aiBox.appendChild(aiLog);

// Click handler using YOUR askAI()
helpBtn.addEventListener('click', async () => {
  try {
    if (aiBox.hidden) aiBox.hidden = false;
    //if (followupInput.hidden) followupInput.hidden = false;

    //const extra = followupInput.value.trim();
    //const followup = extra ? extra : "";

       // Call your existing helper (must return { userMsg, answer })
    //const { userMsg, answer, panelText } = await askAI({ qid: q.id, followup });

    //Also call the chatkit ai 
    await askCKAI(q.id, aiCk);

    // --- Convert Markdown to HTML ---
    // lightweight inline markdown support (basic bold, italic, lists)
    //const block = normalizeBracketMath(`${userMsg}\n${answer}\n\n`);

    // Build ONLY the new turn’s markdown
    //const rawBlock = `${userMsg}\n\n${answer}\n\n---\n`;
    //const withMath = rawBlock;
    // C) Markdown → HTML → sanitize
    //const newHTML = DOMPurify.sanitize(marked.parse(rawBlock));

    //const turn = document.createElement('div');
    //turn.className = 'tex2jax_process'; // ensure MathJax processes this node
    //turn.innerHTML = newHTML;
    //aiLog.appendChild(turn);

    //console.log(newHTML);
    // Scroll to bottom
    //aiLog.style.display = 'block';
   // aiLog.scrollTop = aiLog.scrollHeight;

    // Ask MathJax to typeset just the new node
    //if (window.MathJax?.typesetPromise) {
    //  console.log("processing math");
    //  await MathJax.typesetPromise([aiCk]);
    //  console.log("done with math");
   // }


    // ✅ append as HTML
    //aiLog.insertAdjacentHTML('beforeend', blockHTML);

    //followupInput.value = '';
  } catch (err) {
    console.error(err);
    alert(err.message || 'AI help failed.');
  }


});
function mdToHtml(md='') {
  return marked.parse(md);
}
function escapeHtml(s='') {
  return s.replace(/[&<>"']/g, ch => (
    { '&':'&nbsp;&amp;', '<':'&lt;', '>':'&gt;', '"':'&quot;', "'":'&#39;' }[ch]
  )).replace('&nbsp;&amp;','&amp;'); // keep &amp; correct
}

// Put input to the LEFT of the button, as requested
//aiRow.appendChild(followupInput);
aiRow.appendChild(helpBtn);

// Insert into the card
card.appendChild(aiRow);
card.appendChild(aiBox);
// --------- end per-question AI help UI ---------

        document.getElementById('exam').appendChild(card);
      }
    }

    function finalizeTestAndRender() {
      const total = state.selected.length;
      const correct = state.correctIds.size;
      const pct = Math.round((correct / total) * 100);
      const pass = pct >= 80;

      const summary = document.getElementById('summary');
      const scoreLine = document.getElementById('scoreLine');
      scoreLine.textContent = pass
        ? `You passed with ${pct}% (${correct}/${total} correct).`
        : `You failed with ${pct}% (${pct}%: ${correct}/${total} correct).`;

      const tracking = {
        presented_question_ids: state.presentedIds,
        correct_question_ids: Array.from(state.correctIds),
        wrong_question_ids: Array.from(state.wrongIds)
      };
      document.getElementById('tracking').textContent = JSON.stringify(tracking, null, 2);
      summary.hidden = false;

      accumulateStatsFromCurrentTest();
      state.stats.history.push({ ts: nowIso(), scorePct: pct });

      renderAllCharts(state.stats);
      document.getElementById('newExamBtn').disabled = false;
      window.scrollTo({ top: document.getElementById('charts').offsetTop, behavior: 'smooth' });
    }

    function accumulateStatsFromCurrentTest() {
      for (const q of state.selected) {
        const keySub = `E${q.subelement}`;
        const keyGrp = q.group_index;
        const wasCorrect = state.correctIds.has(q.id);

        if (!state.stats.subelements[keySub]) state.stats.subelements[keySub] = { correct:0, wrong:0 };
        state.stats.subelements[keySub][wasCorrect ? 'correct':'wrong']++;

        if (!state.stats.groups[keySub]) state.stats.groups[keySub] = {};
        if (!state.stats.groups[keySub][keyGrp]) state.stats.groups[keySub][keyGrp] = { correct:0, wrong:0 };
        state.stats.groups[keySub][keyGrp][wasCorrect ? 'correct':'wrong']++;
      }
    }

    function startNewExam(questions) {
      state.selected = buildExam(questions);
      document.getElementById('summary').hidden = true;
      renderExam();
    }

    function updateHashWithStats() {
      const encoded = encodeState(state.stats);
      const url = location.origin + location.pathname + '#c=' + encoded;
      location.assign(url);
    }
    function restoreStatsFromHash() {
      const m = location.hash.match(/^#c=([^&]+)/);
      if (!m) return false;
      const data = decodeState(m[1]);
      if (!data) return false;
      state.stats.history     = Array.isArray(data.history) ? data.history : [];
      state.stats.subelements = typeof data.subelements === 'object' && data.subelements ? data.subelements : {};
      state.stats.groups      = typeof data.groups === 'object' && data.groups ? data.groups : {};
      renderAllCharts(state.stats);
      return true;
    }

    document.getElementById('newExamBtn').addEventListener('click', () => {
      updateHashWithStats();
      if (state.all.length) startNewExam(state.all);
    });

    restoreStatsFromHash();

    /* =========================
       Init: load pool, ensure vector store, render
    ========================= */
    async function init() {
      try {
        const pool = await loadPool();
        state.all = pool;
        // Ensure the vector store exists & is indexed (user-owned)
        //await ensureVectorStore(pool);
        startNewExam(state.all);
        document.getElementById('newExamBtn').disabled = false;
      } catch (e) {
        console.error("Init failed:", e);
        alert("Initialization failed: " + e.message);
      }
    }
    window.addEventListener('DOMContentLoaded', init);

/**
 * Prepare an OpenAI Responses API Markdown string for MathJax v3.
 * - Safely leaves code, links, and images alone.
 * - Normalizes $...$ and $$...$$ to \( ... \) / \[ ... \].
 * - Carefully upgrades math-looking (...) and [...] to \( ... \) / \[ ... \].
 *
 * @param {string} md
 * @returns {string} processed Markdown safe for MathJax typesetting
 */
function prepareMdForMathJax(md) {
  if (typeof md !== 'string' || !md) return md || '';

  // A very low-collision placeholder token (ASCII SUB) + kind + index + SUB
  const SUB = '\x1A';
  const hoists = []; // {kind, placeholder, text}
  let text = md;

  // Utilities
  const isEscaped = (s, i) => {
    let b = 0, j = i - 1;
    while (j >= 0 && s[j] === '\\') { b++; j--; }
    return (b % 2) === 1;
  };

  const makePH = (kind, idx) => `${SUB}${kind}${idx}${SUB}`;

  const hoistRange = (start, end, kind) => {
    const idx = hoists.length;
    const slice = text.slice(start, end);
    const ph = makePH(kind, idx);
    hoists.push({ kind, placeholder: ph, text: slice });
    // replace slice with placeholder
    text = text.slice(0, start) + ph + text.slice(end);
    return ph.length - (end - start); // delta shift
  };

  // Find next occurrence of a run of backticks (inline code)
  const findNextRun = (s, start, tickCount) => {
    const run = '`'.repeat(tickCount);
    let i = start;
    while (i < s.length) {
      const j = s.indexOf(run, i);
      if (j < 0) return -1;
      if (!isEscaped(s, j)) return j;
      i = j + 1;
    }
    return -1;
  };

  // Balanced finder for (), [], <>; respects escapes.
  const findBalanced = (s, startIdx, openCh, closeCh) => {
    let depth = 0;
    for (let i = startIdx; i < s.length; i++) {
      const c = s[i];
      if (c === openCh && !isEscaped(s, i)) depth++;
      else if (c === closeCh && !isEscaped(s, i)) {
        depth--;
        if (depth === 0) return i;
      }
    }
    return -1; // not found
  };

  // 1) HOIST code fences (``` or ~~~), inline code (`…`), <code>/<pre>, images, and links.
  //    We scan repeatedly until no more hoistable regions are found, preserving left-to-right order.
  (function hoistProtected() {
    let i = 0;
    outer: while (i < text.length) {
      // Fenced code blocks ```...``` or ~~~...~~~
      if ((text.startsWith('```', i) || text.startsWith('~~~', i)) && !isEscaped(text, i)) {
        const fence = text.substr(i, 3);
        const end = text.indexOf(`\n${fence}`, i + 3);
        const closeIdx = end >= 0 ? end + 1 + 3 : -1; // include trailing fence
        const endIdx = (closeIdx >= 0) ? (closeIdx + 0) : -1;
        if (endIdx > 0) {
          i += hoistRange(i, endIdx + 0, 'FENCE');
          continue;
        }
      }

      // HTML <pre>...</pre> or <code>...</code> (very simple scan)
      if (text.startsWith('<pre', i) && !isEscaped(text, i)) {
        const close = text.toLowerCase().indexOf('</pre>', i);
        if (close >= 0) { i += hoistRange(i, close + 6, 'HTMLPRE'); continue; }
      }
      if (text.startsWith('<code', i) && !isEscaped(text, i)) {
        const close = text.toLowerCase().indexOf('</code>', i);
        if (close >= 0) { i += hoistRange(i, close + 7, 'HTMLCODE'); continue; }
      }

      // Inline code spans using backticks (support multi-backtick spans)
      if (text[i] === '`' && !isEscaped(text, i)) {
        // count number of consecutive backticks
        let j = i;
        while (j < text.length && text[j] === '`') j++;
        const count = j - i;
        const close = findNextRun(text, j, count);
        if (close >= 0) {
          const end = close + count;
          i += hoistRange(i, end, 'INCODE');
          continue;
        }
      }

      // Images: ![alt](url(with(paren)))
      if (text[i] === '!' && text[i + 1] === '[' && !isEscaped(text, i)) {
        const bStart = i + 1; // at '['
        const bEnd = findBalanced(text, bStart, '[', ']');
        if (bEnd >= 0 && text[bEnd + 1] === '(') {
          const pEnd = findBalanced(text, bEnd + 1, '(', ')');
          if (pEnd >= 0) { i += hoistRange(i, pEnd + 1, 'IMAGE'); continue; }
        }
      }

      // Links: [text](url(with(paren)))
      if (text[i] === '[' && !isEscaped(text, i)) {
        const bEnd = findBalanced(text, i, '[', ']');
        if (bEnd >= 0 && text[bEnd + 1] === '(') {
          const pEnd = findBalanced(text, bEnd + 1, '(', ')');
          if (pEnd >= 0) { i += hoistRange(i, pEnd + 1, 'LINK'); continue; }
        }
      }

      i++;
    }
  })();

  // 2) Convert $$…$$ -> \[ … \] and $…$ -> \( … \), skipping escaped dollars.
  (function convertDollarMath() {
    let out = '';
    let i = 0;
    while (i < text.length) {
      if (text[i] === '$' && !isEscaped(text, i)) {
        // Count consecutive $
        let j = i;
        while (j < text.length && text[j] === '$') j++;
        const count = j - i;

        if (count >= 2) {
          // display math: find closing $$ (exactly two)
          let k = j;
          let close = -1;
          while (k < text.length) {
            const cand = text.indexOf('$$', k);
            if (cand < 0) break;
            if (!isEscaped(text, cand)) { close = cand; break; }
            k = cand + 1;
          }
          if (close >= 0) {
            const inner = text.slice(j, close);
            out += '\\[' + inner + '\\]';
            i = close + 2;
            continue;
          }
        }

        if (count === 1) {
          // inline math: find next unescaped single $
          let k = j;
          let close = -1;
          while (k < text.length) {
            const cand = text.indexOf('$', k);
            if (cand < 0) break;
            if (!isEscaped(text, cand)) { close = cand; break; }
            k = cand + 1;
          }
          if (close >= 0) {
            const inner = text.slice(j, close);
            out += '\\(' + inner + '\\)';
            i = close + 1;
            continue;
          }
        }
      }

      out += text[i++];
    }
    text = out;
  })();

  // Helper: decide if content probably contains TeX (to avoid false positives).
  const looksLikeTeX = (s) => {
    // Ignore whitespace-only
    if (!s || !s.trim()) return false;
    // Heuristics: contains a TeX control sequence or ^/_ usage typical of math
    if (/[\\](?:[a-zA-Z]+|[{}[\]])/.test(s)) return true;     // \alpha, \frac, \sqrt, \int, \sum, \omega, \left, \right, \{ \}
    if (/[^^]\^[^{\s]/.test(' ' + s)) return true;            // x^2 or x^y
    if (/_\{?[\w\\]/.test(s)) return true;                    // x_{i}, x_i, A\_i
    // Reject obvious URLs/emails
    if (/(https?:\/\/|www\.|[@]\w)/i.test(s)) return false;
    // Avoid common non-math bracketed things like [1], (c), (tm), (C++), (v1.2.3)
    if (/^\s*[\[\(]?\s*(?:\d+|[ct]m|v?\d+(?:\.\d+){1,3}|c\+\+)\s*[\]\)]?\s*$/i.test(s)) return false;
    return false;
  };

  // 3) Upgrade parenthesized or square-bracketed TeX-looking runs to \( … \) / \[ … \].
  //    We must *not* touch: already-converted \(...\)/\[...\], link/image brackets, code, footnotes like [1].
  (function upgradeParensAndBrackets() {
    // To avoid index shifting, collect replacements, then rebuild once.
    const replacements = new Map(); // key: open/close index -> replacement char(s)

    // Scan for \( ... \) / \[ ... \] already present and hoist them (so we don’t reprocess)
    (function hoistExistingTexDelims() {
      let i = 0;
      while (i < text.length) {
        if (text[i] === '\\' && (text[i + 1] === '(' || text[i + 1] === '[')) {
          const open = text[i + 1];
          const close = (open === '(') ? '\\)' : '\\]';
          const findClose = text.indexOf(close, i + 2);
          if (findClose >= 0) {
            i += hoistRange(i, findClose + 2, 'TEXDELIM');
            continue;
          }
        }
        i++;
      }
    })();

    // Now safely search for () and [] in the remaining text (links/images already hoisted).
    const scanPairs = (openCh, closeCh, openRep, closeRep, isDisplay) => {
      const stack = [];
      for (let i = 0; i < text.length; i++) {
        const c = text[i];
        if (c === openCh && !isEscaped(text, i)) {
          stack.push(i);
        } else if (c === closeCh && !isEscaped(text, i)) {
          if (!stack.length) continue;
          const start = stack.pop();
          const inner = text.slice(start + 1, i);

          // Skip footnotes like [1], [^1], and empty-ish brackets
          if (openCh === '[') {
            if (/^\s*(?:\^?\d+)\s*$/.test(inner)) continue;
          }

          // Only convert if it *really* looks like TeX
          if (looksLikeTeX(inner)) {
            replacements.set(start, openRep);
            replacements.set(i, closeRep);
          }
        }
      }
    };

    // Parentheses: \( … \)
    scanPairs('(', ')', '\\(', '\\)', false);
    // Brackets: \[ … \]  (but do NOT touch ones that could be links—already hoisted)
    scanPairs('[', ']', '\\[', '\\]', true);

    if (replacements.size) {
      let out = '';
      for (let i = 0; i < text.length; i++) {
        if (replacements.has(i)) out += replacements.get(i);
        else out += text[i];
      }
      text = out;
    }
  })();

  // 4) Unhoist in reverse order to restore original protected content.
  for (let i = hoists.length - 1; i >= 0; i--) {
    const { placeholder, text: original } = hoists[i];
    text = text.split(placeholder).join(original);
  }

  return text;
}

/**
 * Return a Markdown-formatted question for a given qid.
 * Example output:
 *
 * Question:
 * “What is the maximum power permitted on the 2200-meter band?”
 *
 * A. 50 watts PEP (peak envelope power)
 *
 * B. 100 watts PEP (peak envelope power)
 *
 * C. 1 watt EIRP (equivalent isotropic radiated power) ✅
 *
 * D. 5 watts EIRP
 *
 * @param {number|string} qid
 * @param {Array<Object>} [pool=state.all]
 * @returns {string} Markdown text
 */
function getQuestionMarkdown(qid, pool = state.all) {
  if (!Array.isArray(pool) || pool.length === 0) {
    throw new Error('Question pool is empty — load it first.');
  }

  const q = pool.find(r => String(r.id) === String(qid));
  if (!q) throw new Error(`Question id ${qid} not found.`);

  const sanitize = (t) => (t ?? "").toString().trim();
  const letterToField = (L) => ({ A: "answer_a", B: "answer_b", C: "answer_c", D: "answer_d" }[L]);

  const questionText = sanitize(q.question);
  const correctLetter = sanitize(q.answer).toUpperCase();

  // Build formatted Markdown
  let md = `**Question:**\n“${questionText}”\n\n`;

  ['A', 'B', 'C', 'D'].forEach(letter => {
    const field = letterToField(letter);
    const text = sanitize(q[field]);
    if (text) {
      const mark = (letter === correctLetter) ? ' ✅' : '';
      md += `${letter}. ${text}${mark}\n\n`;
    }
  });

  return md.trim();
}
    
  </script>
</body>
</html>
